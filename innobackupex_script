#!/usr/bin/env bash


# --no-timestamp:
# 这个选项不创建一个时间戳的目录来存储备份
# --use-memory:
# 通过使用更多的内存，准备过程可以加快速度。它依赖于您的系统上的免费或可用RAM，默认为100MB。
# 一般来说，进程的内存越多越好。进程中使用的内存的数量可以由多个字节来指定:
# --compress:
# 压缩选项
# --compress-threads:
# 压缩线程
# --incremental-basedir:
# 增量备份的基础路径(上次备份路径)
# --incremental:
# 增量备份选项


BAK_PATH=/data/database_backup
CURRENT_DATE=$(date +%Y%m%d)
LOG_FILE="mysql_back_info_${CURRENT_DATE}.log"
LOG_DIR='/var/log/mysql_back'
USER='bkpuser'
PASS='OLidp2L5fOW2I1sm'
CONF_FILE='/etc/my.cnf'
SOCK_FILE='/data/db/mysql/var/mysql.sock'
DATA_DIR='/data/db/mysql/var'
BASE_DIR=${BAK_PATH}/${CURRENT_DATE}
SCRIPT_DIR='/root/scripts'
ADMIN_PASS='password'


if [ "$UID" -ne 0 ];then
    echo "You must run as root"
    exit
fi

if [ ! -d ${LOG_DIR} ];then
    mkdir -p ${LOG_DIR}
else
    :
fi

if [ ! -d ${BASE_DIR} ];then
    mkdir -p ${BASE_DIR}
fi

do_install(){
    yum install http://www.percona.com/downloads/percona-release/redhat/0.1-4/percona-release-0.1-4.noarch.rpm -y
    yum install percona-xtrabackup-24 -y
}


do_full_backup() {
    innobackupex \
    --defaults-file=${CONF_FILE} \
    --user=${USER} \
    --password=${PASS} \
    --use-memory=4G \
    --compress \
    --compress-threads=4 \
    -S ${SOCK_FILE} \
    ${BASE_DIR} >> ${LOG_DIR}/${LOG_FILE} 2>&1

    num=$?
    if [ "$num" -eq 0 ];then
        echo "full backup OK."
    else
        echo "full backup FAIL"
        exit ${num}
    fi

    do_write_file
}

do_write_file(){
    if [ ! -d ${SCRIPT_DIR}/${CURRENT_DATE} ];then
        mkdir -p ${SCRIPT_DIR}/${CURRENT_DATE}
    fi

    ls -rt1 ${BASE_DIR} | tail -n 1 > ${SCRIPT_DIR}/${CURRENT_DATE}/back.lock
}


do_read_file() {
    echo $(cat ${SCRIPT_DIR}/${CURRENT_DATE}/back.lock)
}

do_inc_backup(){
    LAST_BACKUP_DIR=`do_read_file`
    echo ${LAST_BACKUP_DIR}
    if [ -z ${LAST_BACKUP_DIR} ];then
        echo "Not found last_backup_dir.data file"
        exit 1
    else
        innobackupex \
        --defaults-file=${CONF_FILE} \
        --user=${USER} \
        --password=${PASS} \
        -S ${SOCK_FILE} \
        --use-memory=4G \
        --compress \
        --compress-threads=4 \
        --incremental-basedir=${BASE_DIR}/${LAST_BACKUP_DIR} \
        --incremental \
        ${BASE_DIR} >> ${LOG_DIR}/${LOG_FILE} 2>&1

        num="$?"
        if [ "${num}" -eq 0 ];then
            echo "INC backup Success."
            do_write_file
        else
            echo "INC backup Failed."
            exit ${num}
        fi
    fi
}


do_write_list(){
    if [ -d ${BAK_PATH}/$1 ]; then
        if test -f ${BAK_PATH}/$1/list.lock;then
            echo "list.lock存在" >> ${LOG_DIR}/recovery_info_${CURRENT_DATE}.log 2>&1
            exit 1
        fi

        ls -tr1  ${BAK_PATH}/$1 > ${SCRIPT_DIR}/list.lock
    else
        exit 1
    fi
}

do_merge_backup(){
    recovery_time=$1
    recovery_date=$2
    end_line_number=$(grep -n "$recovery_time" list.lock | awk -F':' '{print $1}')
    # echo ${end_line_number}
    if [ -f ${SCRIPT_DIR}/list.lock ];then
        for ((counter=1; counter<=${end_line_number}; ++counter))
        do
            dir_name=$(cat ./list.lock | awk 'NR=="'${counter}'"{print}')
            if [ ${counter} -eq 1 ];then
            # 取回全量备份
                innobackupex \
                --decompress \
                --parallel=4 \
                ${BAK_PATH}/${recovery_date}/${dir_name} >> ${LOG_DIR}/recovery_info_${CURRENT_DATE}.log 2>&1
                find  ${BAK_PATH}/${recovery_date}/${dir_name} -name "*.qp" -delete
                innobackupex \
                --apply-log \
                --redo-only \
                --use-memory=4G \
                ${BAK_PATH}/${recovery_date}/${dir_name} >> ${LOG_DIR}/recovery_info_${CURRENT_DATE}.log 2>&1
                # 定义全量备份目录变量
                full_backup_dir=${BAK_PATH}/${recovery_date}/${dir_name}
            elif [ ${counter} -eq ${end_line_number} ];then
            # 合并最后一个增量，不需要--redo-only参数
                innobackupex \
                --decompress \
                --parallel=4 \
                ${BAK_PATH}/${recovery_date}/${dir_name} >> ${LOG_DIR}/recovery_info_${CURRENT_DATE}.log 2>&1
                find ${BAK_PATH}/${recovery_date}/${dir_name} -name "*.qp" -delete
                innobackupex \
                --apply-log \
                --use-memory=4G \
                ${full_backup_dir} \
                --incremental-dir=${BAK_PATH}/${recovery_date}/${dir_name} >> ${LOG_DIR}/recovery_info_${CURRENT_DATE}.log 2>&1
            else
            # 合并非全量备份和非最后一次的增量备份
                innobackupex \
                --decompress \
                --parallel=4 \
                ${BAK_PATH}/${recovery_date}/${dir_name} >> ${LOG_DIR}/recovery_info_${CURRENT_DATE}.log 2>&1
                find ${BAK_PATH}/${recovery_date}/${dir_name} -name "*.qp" -delete
                innobackupex \
                --apply-log \
                --use-memory=4G \
                --redo-only \
                ${full_backup_dir} \
                --incremental-dir=${BAK_PATH}/${recovery_date}/${dir_name} \
                >> ${LOG_DIR}/recovery_info_${CURRENT_DATE}.log 2>&1
            fi
        done
    fi
}

do_packaging_backup(){
    innobackupex \
    --defaults-file=${CONF_FILE} \
    --user=${USER} \
    --password=${PASS} \
    -S ${SOCK_FILE} \
    --stream=tar ./ | gzip -> ${BAK_PATH}/${CURRENT_DATE}_all.tar.gz
}

do_recovery(){
    read -p "输入日期[2018-02-23 17-00-00]: "
    recovery_time=$REPLY
    recovery_date=$(echo ${recovery_time} | awk -F '[-," "]' '{print $1$2$3}')
    recovery_datetime=$(echo ${recovery_time} | awk '{gsub(" ","_"); print $1$2}')
    do_write_list ${recovery_date}
    do_merge_backup ${recovery_datetime} ${recovery_date}
    service mysqld stop
    dir_name=$(cat ${SCRIPT_DIR}/list.lock | awk 'NR==1{print}')
    innobackupex \
    --apply-log \
    ${BAK_PATH}/${recovery_date}/${dir_name} >> ${LOG_DIR}/recovery_info_${CURRENT_DATE}.log 2>&1
    if [ $? -eq 0 ];then
        echo "开始回滚所有未提交的事务" > ${LOG_DIR}/recovery_info_${CURRENT_DATE}.log 2>&1
    else
        echo -e "开始回滚所有未提交的事务失败，请尝试手动执行命令: \ninnobackupex
        --apply-log ${BAK_PATH}/${recovery_date}/${dir_name}" >> ${LOG_DIR}/recovery_info_${CURRENT_DATE}.log 2>&1
        exit 1
    fi

    if test -d ${DATA_DIR}; then
        echo -e "${DATA_DIR}目录存在, 在回写时将失败，所以这里选退出了,请手动执行: \ninnobackupex
        --copy-back ${BAK_PATH}/${recovery_date}/${dir_name}" >> ${LOG_DIR}/recovery_info_${CURRENT_DATE}.log 2>&1
        exit 1
    fi

    innobackupex \
    --copy-back \
    ${BAK_PATH}/${recovery_date}/${dir_name} >> ${LOG_DIR}/recovery_info_${CURRENT_DATE}.log 2>&1
    if [ $? -eq 0 ];then
        chown -R mysql.mysql ${DATA_DIR}
        service mysqld start
        rm -f ${SCRIPT_DIR}/list.lock
    else
        exit 1
    fi
}

do_replay_binlog(){
    read -p "输入时间[比如: 2018-02-23 17-10-10]: " recovery_day recovery_time
    stop_time=$(echo ${recovery_time} | awk '{gsub("-", ":");print $1$2$3}')
    sub_backup_dir=$(echo ${recovery_day} | awk -F '-' '{print $1$2$3}')
    hour=$(echo ${recovery_time} | awk -F '-' '{print $1}')
    ((next_hour=${hour} + 1))
    current_inc_string=${recovery_day}_${hour}*
    next_inc_string=${recovery_day}_${next_hour}*
    current_inc_dir=$(find ${BAK_PATH}/${sub_backup_dir}/ -name "${current_inc_string}")

    if test -f ${current_inc_dir}/xtrabackup_binlog_info;then
        begin_file=$(cat ${current_inc_dir}/xtrabackup_binlog_info | awk '{print $1}')
        begin_position=$(cat ${current_inc_dir}/xtrabackup_binlog_info | awk '{print $2}')
    else
        exit 1
    fi

    next_inc_dir=$(find ${BAK_PATH}/${sub_backup_dir}/ -name "${next_inc_string}")
    if [ -d ${next_inc_dir} ];then
        if test -f ${next_inc_dir}/xtrabackup_binlog_info.qp;then
            innobackupex \
            --decompress \
            --parallel=4 \
            ${next_inc_dir} >> ${LOG_DIR}/recovery_info_${CURRENT_DATE}.log 2>&1
            find ${BAK_PATH}/${recovery_date}/${dir_name} -name "*.qp" -delete
        fi
        end_file=$(cat ${next_inc_dir}/xtrabackup_binlog_info | awk '{print $1}')

        mysqlbinlog ${begin_file} ${end_file} \
        --start-position=${begin_position} \
        --stop-datetime="${recovery_day} ${stop_time}" | mysql -u root -p${ADMIN_PASS}
    else
        end_file=${begin_file}
        mysqlbinlog ${begin_file} \
        --start-position=${begin_position} \
        --stop-datetime="${recovery_day} ${stop_time}" | mysql -u root -p${ADMIN_PASS}
    fi
}

case $1 in
    full)
    do_full_backup
    ;;
    inc)
    do_inc_backup
    ;;
    install)
    do_install
    ;;
    packaging)
    do_packaging_backup
    ;;
    recovery)
    do_recovery
    ;;
    binlog)
    do_replay_binlog
    ;;
    *)
    echo "Usage: $0 <params: [full|inc|recovery|packaging]>"
    echo
    echo "full: 全量备份"
    echo "inc: 增量备份"
    echo "recovery: 恢复备份"
    echo "packaging: 打包备份"
    echo
    ;;
esac
